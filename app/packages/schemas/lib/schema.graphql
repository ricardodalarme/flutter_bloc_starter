schema {
  query: Query
  mutation: Mutation
}
"A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar."
scalar DateTime
"The `Upload` scalar type represents a file upload."
scalar Upload
"The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."
scalar JSONObject
type Query {
  "Query that finds apps and return them."
  apps(after: String, filter: AppFilterInput, first: Int): AppConnection
  dummyNotificationsQuery: Int!
  dummyQuery: Int!
  home: Home!
  """
  Query that returns the user associated with the given access token in the
  Authorization header.
  """
  me: User @deprecated(reason: "preferred way is to use `viewer`")
  node(id: ID!): Node
  "Query that finds organizations and return them."
  organizations(
    after: String
    before: String
    filter: OrganizationFilterInput
    first: Int
    last: Int
    order: [OrganizationOrderInput!]
  ): OrganizationConnection
  "Query that finds and return a list of paginated posts"
  posts(after: String, filter: PostFilterInput, first: Int): PostConnection
  """
  Query that lists existing terms and optionally filter by title, content
  or tags in order to fetch its id, which can be used elsewhere in the app.

  If both params are empty, all terms will be returned paginated.
  It serves as the entry point for all the Terms Services.

  The user must have the `terms-read` permission in order to see the
  `Term` attributes.

  See example [GetPaginatedTerms](docs/design/0001-terms-GetPaginatedTerms.gql)
  """
  terms(
    after: String
    filter: TermFilterInput
    first: Int
    order: [TermOrderInput!]
  ): TermConnection
  """
  This query will try to to find the user with the email given in the argument
  .

  Requires permissions: `users-read`
  """
  user(email: String!): User
  """
  Query that gets all available users.

  Requires permissions: `users-read`
  """
  users(after: String, filter: UserFilterInput, first: Int): UserConnection
  "Query that finds and return a list of videos"
  videos: VideoConnection
  """
  Query that returns the user and their permissions with the given access token
  in the Authorization header.
  """
  viewer: ViewerPayload
  "Query that finds webhooks and returns them."
  webhooks(
    after: String
    filter: WebhookFilterInput
    first: Int
  ): WebhookConnection!
}
"Type responsible for `App` connection and pagination"
type AppConnection {
  nodes: [App!]!
  pageInfo: PageInfo!
}
"""
Type associated with all `App` related info


You need the `apps-read` permission to read a given
app, otherwise a forbidden error will be thrown.
"""
type App implements Node {
  "Field that holds the app's description."
  description: String
  "Field that indicates if an app is enabled or not."
  enabled: Boolean
  "Field that holds the apps' unique identifier."
  id: ID!
  "Field that holds the app's name."
  name: String
  "Field that holds a list of urls to be redirected."
  redirectURL: [String!]
}
type PageInfo {
  endCursor: String
  hasNextPage: Boolean
  hasPreviousPage: Boolean
  startCursor: String
}
type Home {
  elements: [HomeElement!]!
}
type HomeElementText {
  id: String!
  kind: HomeElementTextKind
  value: String!
}
"""
Type assigned to the user entity, holds all information related to a user.

Has permissions: `users-read`.
"""
type User implements Node {
  """
  This field returns all agreed terms that a user has ever agreed to.

  Requires the `terms-agreements-read` permission.

  Can be used in conjunction with the login mutation to immediately login and
  get all agreed terms, similar to
  [LoginAndGetPendingTerms](docs/design/0000-user-LoginAndGetPendingTerms.gql)
  """
  agreedTerms(after: String, first: Int): TermVersionAgreementConnection
  "String that holds an user's email"
  email: String!
  "Nullable string that can hold an user's first name"
  firstName: String
  "An user's unique identifier"
  id: ID!
  """
  This field returns the last version of a given term that a user has agreed to.

  Requires the `terms-agreements-read` permission.
  """
  lastAgreedTermVersion(termId: ID!): TermVersionAgreement
  "Nullable string that can hold an user's last name"
  lastName: String
  "Nullable string that can hold an user's full name"
  name: String
  "The organizations that the user belongs to."
  organizations(
    after: String
    before: String
    first: Int
    last: Int
  ): OrganizationEdgeConnection
  """
  This field returns all of latest published the term versions that the user
  still hasn't agreed to.

  Requires the `terms-agreements-read` permission.
  """
  pendingAgreements(after: String, first: Int): TermVersionConnection
  "The list of posts created by the user."
  posts: [Post!]
  "String that holds an user's profile picture"
  profilePicture: Download
  "String that holds an user's username"
  username: String!
}
"Type responsible for `TermVersionAgreement` connection and pagination"
type TermVersionAgreementConnection {
  nodes: [TermVersionAgreement!]!
  pageInfo: PageInfo!
  totalCount: Int!
}
"Type associated with all info related to a agreed term"
type TermVersionAgreement implements Node {
  "Field that says whether it was agreed or declined"
  agreed: Boolean!
  "Field that holds the date on which this term's version was agreed to."
  agreedAt: DateTime!
  "Field that holds the unique identifier for this type"
  id: ID!
  "Field that holds the term that this agreed version belongs to."
  term: Term!
  "Nullable field that can hold the user that agreed to this term."
  user: User
  "Field that holds the version of the agreed term."
  version: TermVersion!
}
"""
Type associated with all `Term` related info, the user must have permission
`terms-read` to access its information
"""
type Term implements Node {
  """
  Given a `userId`, this nullable field holds the all the agreed term
  versions that a user has ever agreed to. If no userId is passed, the id used
  is going to be the one that belongs to whomever made the request.

  You need at least the `terms-agreements-read` permission to read this
  field, otherwise a forbidden error will will be thrown.

  You also need the `terms-agreements-read-given-user` to read a given
  user's agreements, otherwise a forbidden error will be thrown.
  """
  agreedVersions(
    after: String
    first: Int
    userId: ID
  ): TermVersionAgreementConnection
  "Field that holds the term's description."
  description: String!
  "Field that holds the term's unique identifier."
  id: ID!
  """
  Given a `userId`, this nullable field holds the **last** term version
  that the user has agreed to.

  If no `userId` is passed through the arguments, the `userId` used
  is going to be the one that belongs to whomever made the request.

  This version might not be the latest version, in which case one might
  prompt the user to agree to the latest one with the
  `latestPublishedVersion` field.

  You need at least the `terms-agreements-read` permission to read this
  field.

  You also need the `terms-agreements-read-given-user` to read a given
  user's agreements, otherwise a forbidden error will be thrown.
  """
  lastAgreement(userId: ID): TermVersionAgreement
  """
  This nullable field holds the latest version released for a term.

  Even though a term can have multiple versions, only one of them can be the
  latest.
  """
  latestPublishedVersion: TermVersion
  """
  Given a `userId`, this nullable field holds the latest version pending
  term that the user has to agree to, if there is any.

  If no `userId` is passed through the arguments or the user doesn't have
  the `terms-agreements-read` permission, the `userId` used is going to
  be the one that belongs to whomever made the request.
  """
  pendingAgreement(userId: ID): TermVersion
  "Nullable Field that can hold the term's tags if they have any."
  tags: [String!]
  """
  Field that holds the term's title.

  A term's title is unique.
  """
  title: String!
  """
  A term can have multiple versions, this field holds a connection to all
  `TermVersion` objects a term can have. If the user has the
  `terms-update` permission it will be able to see also draft versions.
  """
  versions(
    after: String
    filter: TermVersionFilterInput
    first: Int
    order: [TermVersionOrderInput!]
  ): TermVersionConnection
}
"""
Type associated with all info of a term's version, the user must have
permission `terms-read` to access its information
"""
type TermVersion implements Node {
  "Field that holds the body of a term's version."
  body: String!
  "Field that indicates when a term version was created."
  createdAt: DateTime!
  "Field that holds the description of the term's version."
  description: String!
  """
  Field that holds the latest [ETag](https://en.wikipedia.org/wiki/HTTP_ETag).

  This helps prevent mid-air collisions, as well as allows caches to be more
  efficient and saves bandwidth.

  To edit a unpublished term version or publish one, a `ifMatchesETag`
  variable needs to be sent. The variable needs to be the same as this ETag,
  otherwise an error will be returned to user.
  """
  etag: String!
  "Field that holds an unique identifier of the term's version."
  id: ID!
  """
  Field that indicates if a term was published or not.

  Published versions can't be modified or deleted.
  """
  isPublished: Boolean!
  "Field that holds the term that this version belongs to."
  term: Term!
  "Field that indicates when a term version was last updated."
  updatedAt: DateTime!
  """
  Field that holds a human understandable string that identifies the
  version.

  This version is unique.
  """
  version: String!
}
"Type responsible for `TermVersion` connection and pagination"
type TermVersionConnection {
  nodes: [TermVersion!]!
  pageInfo: PageInfo!
  totalCount: Int!
}
"Type responsible for `userOrganizationEdge` connection and pagination"
type OrganizationEdgeConnection {
  nodes: [UserOrganizationEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}
"""
Type associated with all relations between a user and its related organizations.

The user-organization relation have cardinality many-to-many.
"""
type UserOrganizationEdge {
  "Field that holds the organization's reference."
  organization: Organization!
  "Field that holds the user's role at organization."
  role: UserOrganizationRole!
  "Field that holds the userOrganizationstatus's status."
  status: UserOrganizationEdgeStatus!
  "Field that holds the user's reference."
  user: User!
}
"""
Type associated with all `Organization` related info


You need the `organizations-read` permission to read a given
organization, otherwise a forbidden error will be thrown.
"""
type Organization implements Node {
  "Field that holds the organization's corporate taxpayer registry."
  corporateTaxpayerRegistry: String!
  "Field that holds the organization's description."
  description: String
  "Field that holds the organization's email."
  email: String
  """
  Field that holds the latest [ETag](https://en.wikipedia.org/wiki/HTTP_ETag).

  This helps prevent mid-air collisions, as well as allows caches to be more
  efficient and saves bandwidth.

  To update a given organization, a `ifMatchesETag` variable needs to be
  sent. The variable needs to be the same as this ETag, otherwise an error
  will be returned to user.
  """
  etag: String
  "Field that holds the organizations' unique identifier."
  id: ID!
  "field that holds organization logo information"
  logo(disposition: String): Download
  "Field that holds the name of the organization"
  name: String
  "Field that holds the organization's status."
  status: OrganizationStatus!
  "Field that holds the organization's tags."
  tags: [String!]
  "Field that holds the organization's trading name."
  tradingName: String
  """
  Field that holds the organization's users.

  Use the mutations `addUserToOrganization` and
  `removeUserFromOrganization` to add or remove a user from a organization
  """
  users(
    after: String
    filter: UserOrganizationEdgeFilterInput
    first: Int
  ): OrganizationEdgeConnection
}
type Download {
  encoding: String
  filename: String!
  lastModified: DateTime!
  mimetype: String!
  size: Int!
  url: String!
}
type Post implements Node {
  "Field that holds the post's body."
  body: String!
  "Field that holds the post's creation date."
  createdAt: DateTime!
  "Field that holds the post's user."
  createdBy: User!
  "Fields that holds post's deleted date."
  deletedAt: DateTime
  "Field that holds the post's unique identifier."
  id: ID!
  "Field that holds post's images information."
  images(disposition: String): [Download!]!
  "Field that holds the post's owner (user or organization)"
  owner: PostOwner!
  "Field that holds post's reason given for being removed."
  removalReason: String
  "Field that holds the post's title."
  title: String!
}
"Type responsible for `Organization` connection and pagination"
type OrganizationConnection {
  nodes: [Organization!]!
  pageInfo: PageInfo!
  totalCount: Int!
}
type PostConnection {
  nodes: [MaybePost!]!
  pageInfo: PageInfo!
  totalCount: Int!
}
type RemovedPost {
  "Fields that references post's deleted date."
  deletedAt: DateTime!
  "Field that references the post's unique identifier."
  id: ID!
  "Field that references post's removal reason."
  removalReason: String!
}
"Type used for term pagination."
type TermConnection {
  nodes: [Term!]!
  pageInfo: PageInfo!
  totalCount: Int!
}
"Type associated with User pagination"
type UserConnection {
  nodes: [User!]
  pageInfo: PageInfo!
  totalCount: Int!
}
type VideoConnection {
  nodes(id: ID): [Video!]
}
"Type assigned to the user entity, holds all information related to a video."
type Video implements Node {
  "Nullable string that can hold a video's description"
  description: String
  "Nullable number that can hold a video's duration"
  duration: Float
  "Nullable string that can hold a link of video's hls_url"
  hls_url: String
  "An video's unique identifier"
  id: ID!
  "Nullable string that can hold a video's name"
  name: String
  "Nullable string that can hold a link of video's poster_thumb"
  poster_thumb: String
  "Nullable string that can hold a video's projection"
  projection: String
}
type ViewerPayload {
  permissions: [String!]
  user: User
}
"Type used for webhook pagination."
type WebhookConnection {
  nodes: [Webhook!]!
  pageInfo: PageInfo!
  totalCount: Int!
}
"Type associated with all `Webhook` related info."
type Webhook implements Node {
  "Field that holds webhook's status."
  active: Boolean!
  "Field that holds webhook's configuration"
  config: WebhookConfig!
  "Field that holds webhook's events."
  events: [SubscribableEvents!]!
  "Field that holds webhook's id"
  id: ID!
  "Field that holds webhook's name."
  name: String!
}
"Type associated to relation between a server and a HTTP server."
type WebhookConfig {
  "Field that holds webhook's method."
  method: WebhookRequestMethod!
  "Field that holds HTTP server's url."
  url: String!
}
type Mutation {
  """
  Mutation that activates a specific user.

  Requires permissions: `activate-user`
  """
  activateUser(input: ActivateUserInput!): ActivateUserPayload
  """
  Mutation used to add or update a user profile picture.

  If the logged don't have the "user-profile-picture-update" permission it can
  only be able to change its on profile picture.

  If AddOrUpdateUserProfilePictureInput.userId is null we assume the user
  wants to change its own profile picture.
  """
  addOrUpdateUserProfilePicture(
    input: AddOrUpdateUserProfilePictureInput!
  ): AddOrUpdateUserProfilePicturePayload
  """
  Mutation that adds a user to an organization.

  In order to create a connection between a user and a organization, the
  `user-organization-add` permission is required.
  """
  addUserToOrganization(
    input: AddUserToOrganizationInput!
  ): AddUserToOrganizationPayload
  """
  Mutation that enables a user to agree or disagree to the latest version that is pending.

  When mutation occurs and `termVersionId` is not the latest version,
  the mutation fails and returns an error to the requester, the app must be
  updated to show to the user that he needs to agree with the latest version.

  To agree to the latest version, one needs to send `termVersionId`,
  previously fetched with `GetPendingAgreement`. An user can only agree
  to a published version.

  The user must have the `terms-agreement-create` permission.
  """
  agreeOrDisagreeToTermVersion(
    input: AgreeOrDisagreeToTermVersionInput!
  ): AgreeOrDisagreeToTermVersionPayload
  """
  Mutation that updates a organization's status.

  In order to update a organization's status,
  `organizations-update` permission is required.
  """
  changeOrganizationStatus(
    input: ChangeOrganizationStatusInput!
  ): ChangeOrganizationStatusPayload
  "Mutation that changes the logged user's password."
  changePassword(input: ChangePasswordInput!): ChangePasswordPayload
  changeUserOrganizationEdgeStatus(
    input: ChangeUserOrganizationEdgeStatusInput!
  ): UserOrganizationEdgePayload
  """
  Mutation that creates a new app.

  In order to create the app, the `apps-create` permission
  is required.
  """
  createApp(input: CreateAppInput!): CreateAppPayload
  """
  Mutation that creates a new organization.

  In order to create the organization, the `organizations-create` permission
  is required.
  """
  createOrganization(input: CreateOrganizationInput!): CreateOrganizationPayload
  "Mutation that adds a post."
  createPost(input: CreatePostInput!): CreatePostPayload
  """
  Mutation creates a new term. The newly created term must have an unique
  title and will have an auto-generated termId. An initial version must be
  provided alongside the newly created term, it will be a draft
  (`isPublished: false`) and will also have an auto-generated
  `termVersionId`.

  The user must have `terms-create` permission in order to create new
  terms.

  See example [CreateTerm](docs/design/0001-terms-CreateTerm.gql)
  """
  createTerm(input: CreateTermInput!): CreateTermPayload
  """
  Given a previously fetched term, this mutation creates a new version for it.

  This new term version will be created unpublished (draft or
  `isPublished: false`), and the version field must be unique for that
  term, otherwise, the mutation fails and an error will be returned.

  The requester must have the permission `terms-create` to create a new
  term version.

  See example [CreateTermVersion](docs/design/0001-terms-CreateTermVersion.gql)
  """
  createTermVersion(input: CreateTermVersionInput!): CreateTermVersionPayload
  "Mutation that creates an user."
  createUser(input: CreateUserInput!): CreateUserPayload
  """
  Mutation that deactivate a specific user.

  Requires permissions: `deactivate-user`
  """
  deactivateUser(input: DeactivateUserInput!): DeactivateUserPayload
  """
  Mutation that deletes an existing organization.

  In order to delete the organization, the `organizations-delete` permission
  is required.
  """
  deleteOrganization(input: DeleteOrganizationInput!): DeleteOrganizationPayload
  """
  Mutation used to log in.

  Authenticates the user, returning the access token and the logged in
  User object.

  The login can be done using one of two methods: oauth (OAuthv2) and basic
  (username and password), which will return an access token that is valid
  until expires.

  There is no logout method, only forget about the token (stop using it,
  delete from persistent storage) and let it expire.

  To refresh the token, use the refreshToken mutation.

  A common use case is to retrieve the user information once logs in and
  eventually some other information, such as pending agreements. This can be
  fetched directly [from the mutation](docs/design/0001-terms-AgreeToTermVersion.gql)
  """
  login(credentials: LoginInput!): Login
  """
  Mutation used to logout out of the system.

  Given authentication, this mutation will log the user out of the
  server, revoking the refresh token given.

  Returns True, if the logout was successful.

  To regain access to the server, one must use the login mutation once more.
  """
  logout(refreshToken: String!): Boolean!
  """
  This mutation publishes a term version, given a previously fetched draft
  term version.

  Needs to send `ifMatchesETag` to avoid mid-air collisions, otherwise,
  an error will be returned to user, informing him that permission is not
  accepted or the version term has been modified.

  Once published that version cannot be edited or unpublished. If changes are
  needed, a new version must be created and published.

  The requester must have the permissions `terms-publish` and
  `terms-update`.

  See example [PublishTermVersion](docs/design/0001-terms-PublishTermVersion.gql)
  """
  publishTermVersion(input: PublishTermVersionInput!): PublishTermVersionPayload
  """
  Mutation used to refresh a login, without having to use user credentials
  again.

  Authenticates the user one more time, returning a new access token, refresh
  token and the logged in User object. The refresh token used in this mutation
  will be revoked after its use. Use the new refresh token given by the
  mutation if the login needs to be refreshed again.

  After logging out, the refresh token associated with to the current access
  token will also be revoked.
  """
  refreshToken(tokenInfo: RefreshInput!): Login
  "Mutation that registers a webhook."
  registerWebhook(input: RegisterWebhookInput!): RegisterWebhookPayload
  """
  Mutation that removes an existing post.

  In order to remove the post, the `posts-remove` permission
  is required.
  """
  removePost(input: RemovePostInput!): RemovePostPayload
  """
  Mutation that removes a user to an organization.

  In order to remove a connection between a user and a organization, the
  `user-organization-remove` permission is required.
  """
  removeUserFromOrganization(
    input: RemoveUserFromOrganizationInput!
  ): RemoveUserFromOrganizationPayload
  """
  Mutation that sends a reset password email to the email sent on the input, if
  it is registered.
  """
  resetPassword(input: ResetPasswordInput!): ResetPasswordPayload
  "Mutation that restore a removed post."
  restorePost(input: RestorePostInput!): RestorePostPayload
  "Mutation that triggers a webhook"
  triggerWebhook(input: TriggerWebhookEvent!): TriggerWebhookPayload
  """
  Mutation that updates an existing organization.

  In order to update the organization, the `organizations-update` permission
  is required.
  """
  updateOrganization(input: UpdateOrganizationInput!): UpdateOrganizationPayload
  """
  This mutation can update a term's version, given a draft term version
  previously fetched with `GetPaginatedTermVersionsByTerm` or
  `{ node(id) }` and a `ifMatchesETag` to avoid mid-air collisions.
  Otherwise, an error will be returned to user, informing him that
  something when wrong.

  The requester must have the permission `terms-update`.

  See example [UpdateTermVersion](docs/design/0001-terms-UpdateTermVersion.gql)
  """
  updateTermVersion(input: UpdateTermVersionInput!): UpdateTermVersionPayload
  """
  Mutation that updates a specific user.

  Requires permissions: `users-update`
  """
  updateUser(input: UpdateUserInput!): UpdateUserPayload
}
"This is the result of `activeUser` mutation."
type ActivateUserPayload {
  "The message to be displayed to the user."
  result: String!
}
type AddOrUpdateUserProfilePicturePayload {
  user: User!
}
"Result of the `addUserToOrganization` mutation."
type AddUserToOrganizationPayload {
  userOrganization: UserOrganizationEdge!
}
"""
Result of the `agreeOrDisagreeToTermVersion()` mutation with the `TermVersion`
accepted by the user.
"""
type AgreeOrDisagreeToTermVersionPayload {
  termAgreement: TermVersionAgreement!
}
"Result of the `changeOrganizationStatus` mutation."
type ChangeOrganizationStatusPayload {
  organization: Organization!
}
"Type returned by the mutation `changePassword`"
type ChangePasswordPayload {
  user: User!
}
type UserOrganizationEdgePayload {
  userOrganizationEdge: UserOrganizationEdge!
}
"""
This is the result of `createApp()` and contains the reference.
to the new `App`.
"""
type CreateAppPayload {
  app: App!
}
"""
This is the result of `createOrganization()` and contains the reference.
to the new `Organization`.
"""
type CreateOrganizationPayload {
  organization: Organization!
}
"Result of the `createPost` mutation."
type CreatePostPayload {
  post: Post!
}
"""
This is the result of the `createTerm()` mutation and contains the
reference to the new `Term` and also its initial `TermVersion`. The
created version is a draft (unpublished) and may be edited with
`updateTermVersion()` until it's final, by then one should publish it
with `publishTermVersion()`.
"""
type CreateTermPayload {
  term: Term!
  termVersion: TermVersion!
}
"""
Result of the `createTermVersion()` mutation. The newly created version is
draft (unpublished) and may be updated with `updateTermVersion()` until it's
published with `publishTermVersion()`.
"""
type CreateTermVersionPayload {
  termVersion: TermVersion!
}
"""
This is the result of the `createUser()` mutation and contains the
created user's id.
"""
type CreateUserPayload {
  id: ID!
}
"This is the result of `deactivateUser` mutation."
type DeactivateUserPayload {
  "The message to be displayed to the user."
  result: String!
}
"Result of the `deleteOrganization()` mutation."
type DeleteOrganizationPayload {
  organization: Organization!
}
"Type associated with the login query, has values from a successful login"
type Login {
  "Token that holds a valid auth token."
  accessToken: Token!
  "Token that holds a valid auth refresh token."
  refreshToken: Token!
  "Field that will have a User, if one is requested and found."
  user: User!
}
"Type associated with the login query, has values from a successful login"
type Token {
  "ISO date string that indicates when the given token is going to expire."
  expires: DateTime!
  """
  String that holds a valid auth token.

  It should be sent in the next HTTP requests as
  `Authorization: Bearer {token}`
  """
  token: String!
}
"""
Result of the `publishTermVersion()` mutation. The published version is
no longer a draft and can't be updated with `updateTermVersion()`
anymore.
"""
type PublishTermVersionPayload {
  termVersion: TermVersion!
}
"Result of `registerWebhook` mutation."
type RegisterWebhookPayload {
  webhook: Webhook!
}
"Result of the `removePost()` mutation."
type RemovePostPayload {
  post: RemovedPost!
}
"Result of the `removeUserFromOrganization` mutation."
type RemoveUserFromOrganizationPayload {
  userOrganization: UserOrganizationEdge
}
"This is the result of `resetPassword`."
type ResetPasswordPayload {
  """
  The message to be displayed to the user. It will be localized based on the input's
  locale
  """
  result: String!
}
"Result of the `restorePost()` mutation."
type RestorePostPayload {
  post: Post!
}
"Result of `triggerWebhook` mutation."
type TriggerWebhookPayload {
  webhook: Webhook!
}
"Result of the `updateOrganization()` mutation."
type UpdateOrganizationPayload {
  organization: Organization!
}
"""
Result of the `updateTermVersion()` mutation. The updated version is
draft (unpublished) and may be updated with `updateTermVersion()` again
until it's published with `publishTermVersion()`.
"""
type UpdateTermVersionPayload {
  termVersion: TermVersion!
}
"""
This is the result of the `updateUser()` mutation and contains the
updated User.
"""
type UpdateUserPayload {
  user: User!
}
interface Node {
  id: ID!
}
union HomeElement = HomeElementText
union PostOwner = Organization | User
union MaybePost = Post | RemovedPost
enum HomeElementTextKind {
  h1
  h2
  h3
  h4
  h5
  h6
}
"Enum containing all orderable fields from TermVersion"
enum OrderableTermVersionFields {
  BODY
  CREATED_AT
  DESCRIPTION
  ETAG
  ID
  IS_PUBLISHED
  UPDATED_AT
  VERSION
}
enum OrderInput {
  ASC
  DESC
}
"Enumeration that describes the organization's status."
enum OrganizationStatus {
  ACTIVE
  INACTIVE
}
"Enumeration that describes the userOrganizationEdge's status."
enum UserOrganizationEdgeStatus {
  ACTIVE
  INACTIVE
}
"Enumeration that describes the user's role at organization."
enum UserOrganizationRole {
  ADMIN
  USER
}
"Enum containing all orderable fields from Organization"
enum OrderableOrganizationFields {
  CORPORATE_TAXPAYER_REGISTRY
  DESCRIPTION
  EMAIL
  ETAG
  ID
  NAME
  TAGS
  TRADING_NAME
}
"Enum containing all orderable fields from Term"
enum OrderableTermFields {
  DESCRIPTION
  ID
  TAGS
  TITLE
}
"Enumeration that describes the subscrible events."
enum SubscribableEvents {
  ADD_USER_TO_ORGANIZATION
  REMOVE_USER_FROM_ORGANIZATION
}
"Enumeration that describes the webhook's method."
enum WebhookRequestMethod {
  POST
  PUT
}
enum ForeignNodeIdValidateDirectivePolicy {
  "Field resolver is responsible to evaluate it using `validationErrors` injected in GraphQLResolverInfo"
  RESOLVER
  "Field resolver is not called if occurs a validation error, it throws `UserInputError`"
  THROW
}
enum HasPermissionsDirectivePolicy {
  "Field resolver is responsible to evaluate it using `missingPermissions` injected argument"
  RESOLVER
  "Field resolver is not called if permissions are missing, it throws `ForbiddenError`"
  THROW
}
enum ListLengthValidateDirectivePolicy {
  "Field resolver is responsible to evaluate it using `validationErrors` injected in GraphQLResolverInfo"
  RESOLVER
  "Field resolver is not called if occurs a validation error, it throws `UserInputError`"
  THROW
}
enum PatternValidateDirectivePolicy {
  "Field resolver is responsible to evaluate it using `validationErrors` injected in GraphQLResolverInfo"
  RESOLVER
  "Field resolver is not called if occurs a validation error, it throws `UserInputError`"
  THROW
}
enum RangeValidateDirectivePolicy {
  "Field resolver is responsible to evaluate it using `validationErrors` injected in GraphQLResolverInfo"
  RESOLVER
  "Field resolver is not called if occurs a validation error, it throws `UserInputError`"
  THROW
}
enum SelfNodeIdValidateDirectivePolicy {
  "Field resolver is responsible to evaluate it using `validationErrors` injected in GraphQLResolverInfo"
  RESOLVER
  "Field resolver is not called if occurs a validation error, it throws `UserInputError`"
  THROW
}
enum StringLengthValidateDirectivePolicy {
  "Field resolver is responsible to evaluate it using `validationErrors` injected in GraphQLResolverInfo"
  RESOLVER
  "Field resolver is not called if occurs a validation error, it throws `UserInputError`"
  THROW
}
"Input in a `App` connection to filter apps, according to each field."
input AppFilterInput {
  "If given (non-null), filter is applied to app's clientId."
  clientId: String
}
"""
Input in a `TermVersion` connection to filter versions, according to each
field.

Each filter element will be filtered with an `AND` operation, and each
filter element option will filter using an `OR` operation, for example:

```
{
  "title": {
    "contains": "Policy",
    "startWith": "New",
  },
  "description": {
    "contains": "denied"
  }
}
```

This will search for a `TermVersion` with title containing "Policy" or
starting with "New" that also has a description containing "denied".
"""
input TermVersionFilterInput {
  "If given (non-null), filter is applied to term version's body."
  body: StringFilterInput
  "If given (non-null), filter is applied to term version's createdAt."
  createdAt: DateTimeFilterInput
  "If given (non-null), filter is applied to term version's description."
  description: StringFilterInput
  "If given (non-null), filter is applied to term's title."
  title: StringFilterInput
  """
  If given, the term versions should match exactly (case sensitive, full
  match) the given strings. If more than one version is given, the term must
  contain one of them (OR behavior).
  """
  versions: [String!]
}
input StringFilterInput {
  contains: String
  endsWith: String
  equals: String
  startsWith: String
}
input DateTimeFilterInput {
  between: DateTimeRangeFilterInput
  equals: DateTime
  greaterThan: DateTime
  greaterThanOrEqual: DateTime
  lessThan: DateTime
  lessThanOrEqual: DateTime
}
input DateTimeRangeFilterInput {
  end: DateTime
  start: DateTime
}
"""
Input in a `Term` connection to order terms, according to each field.

Each element will be ordered with an `ASC` or `DESC`, for example:

```
{
  "order": [
    { "ID": "ASC" },
    { "CREATED_AT": "DESC" }
  ]
}
```

This will order the query by "id" in a ascending order and after that, order
by "description" in a descending order.
"""
input TermVersionOrderInput {
  "Field which will be ordered"
  field: OrderableTermVersionFields!
  "Order (ASC or DESC) which will be applied"
  type: OrderInput!
}
"""
Input that holds basic information about userOrganizationEdge's filter.

Used to pass an filter in a query.
"""
input UserOrganizationEdgeFilterInput {
  """
  This field defaults to `UserOrganizationEdgeStatus.ACTIVE`.
  If not given (non-null), filter is applied to the userOrganizationEdge's status.
  If explicitly sent as null, this filter is not applied.
  """
  userOrganizationEdgeStatus: UserOrganizationEdgeStatus = ACTIVE
}
input OrganizationFilterInput {
  """
  If given (non-null), filter is applied to the organization's corporate
  taxpayer registry.
  """
  corporateTaxpayerRegistry: StringFilterInput
  "If given (non-null), filter is applied to the organization's email."
  email: StringFilterInput
  "If given (non-null), filter is applied to the name of the organization"
  name: StringFilterInput
  """
  This field defaults to `OrganizationStatus.ACTIVE`.
  If not given (non-null), filter is applied to the organization's status.
  If explicitly sent as null, this filter is not applied.
  """
  status: OrganizationStatus = ACTIVE
  """
  If given, the organization tags should match exactly (case sensitive, full
  match) the given strings. If more than one tag is given, the organization
  must contain all of them (AND behavior).
  """
  tags: [String!]
  "If given (non-null), filter is applied to the organization's trading name."
  tradingName: StringFilterInput
}
"""
Input in a `Organization` connection to order organizations, according to
each field.

Each element will be ordered with an `ASC` or `DESC`, for example:

```
{
  "order": [
    { "ID": "ASC" },
    { "DESCRIPTION": "DESC" }
  ]
}
```

This will order the query by "id" in a ascending order and after that, order
by "description" in a descending order.
"""
input OrganizationOrderInput {
  "Field which will be ordered"
  field: OrderableOrganizationFields!
  "Order (ASC or DESC) which will be applied"
  type: OrderInput!
}
input PostFilterInput {
  """
  If given (non-null), filter is applied to the organization the posts belong
  to.
  """
  organizations: [ID!]
}
"""
Input in a `Term` connection to filter terms, according to each field.

Each filter element will be filtered with an `AND` operation, and each
filter element option will filter using an `OR` operation, for example:

```
{
  "title": {
    "contains": "Policy",
    "startWith": "New",
  },
  "description": {
    "contains": "denied"
  }
}
```

This will search for a `Term` with title containing "Policy" or starting
with "New" that also has a description containing "denied".
"""
input TermFilterInput {
  "If given (non-null), filter is applied to term's description."
  description: StringFilterInput
  """
  If given, the term tags should match exactly (case sensitive, full match)
  the given strings. If more than one tag is given, the term must contain
  all of them (AND behavior).
  """
  tags: [String!]
  "If given (non-null), filter is applied to term's title."
  title: StringFilterInput
}
"""
Input in a `Term` connection to order terms, according to each field.

Each element will be ordered with an `ASC` or `DESC`, for example:

```
{
  "order": [
    { "ID": "ASC" },
    { "DESCRIPTION": "DESC" }
  ]
}
```

This will order the query by "id" in a ascending order and after that, order
by "description" in a descending order.
"""
input TermOrderInput {
  "Field which will be ordered"
  field: OrderableTermFields!
  "Order (ASC or DESC) which will be applied"
  type: OrderInput!
}
input UserFilterInput {
  email: StringFilterInput
  name: StringFilterInput
  username: StringFilterInput
}
input WebhookFilterInput {
  "If given (non-null), filter is applied to the webhook's status."
  active: Boolean
  "If given (non-null), filter is applied to the webhook's event."
  events: [SubscribableEvents!]
  "If given (non-null), filter is applied to the webhook's title."
  name: StringFilterInput
}
"Input used to update user status given its id."
input ActivateUserInput {
  "Not nullable field that indicates which user should be activated."
  userId: ID!
}
"""
This input holds info for adding or updating a user profile picture,
using user ID and the uploaded profile picture
"""
input AddOrUpdateUserProfilePictureInput {
  "The photo to be added/updated."
  profilePicture: Upload!
  """
  Field that indicates which user have the photo added/updated.
  If `null` the logged user's photo will be added/updated.
  """
  userId: ID
}
"Input used to create a connection between an user and a organization."
input AddUserToOrganizationInput {
  organizationId: ID!
  role: UserOrganizationRole! = USER
  userId: ID!
}
"Input used to agree or disagree to a term's version."
input AgreeOrDisagreeToTermVersionInput {
  "Field that says whether the Term should be agreed to or declined."
  agree: Boolean!
  """
  Field that holds the unique identifier for the term version that is being
  agreed or disagreed.
  """
  termVersionId: ID!
}
"Input used to update organization's status."
input ChangeOrganizationStatusInput {
  """
  String that is used to prevent mid-air collisions. To successfully update an
  organization, this field **has to be the same** as the `etag` field of
  the organization that is being updated.
  If this condition is not met, an error will be returned.
  """
  ifMatchesETag: String!
  "Field that indicates what Organization should have its status changed."
  organizationId: ID!
  "Field that indicates if an organization is active or inactive"
  status: OrganizationStatus!
}
"Input used to update the logged user's password"
input ChangePasswordInput {
  "The user's desired new password"
  newPassword: String!
  "The user's current password"
  oldPassword: String!
}
"Input used to change an userOrganizationEdge's status."
input ChangeUserOrganizationEdgeStatusInput {
  organizationId: ID!
  status: UserOrganizationEdgeStatus!
  userId: ID!
}
"""
Input that holds basic information about an app.

Used to create an `App`.
"""
input CreateAppInput {
  "Field that holds the app's description."
  description: String!
  "Field that indicates if an app is enabled or not."
  enabled: Boolean!
  "Field that holds the app's name."
  name: String!
  "Field that holds a list of urls to be redirected."
  redirectURL: [String!]!
}
"""
Input that holds basic information about an organization.

Used to create an `Organization`.
"""
input CreateOrganizationInput {
  "Field that holds the organization's corporate taxpayer registry."
  corporateTaxpayerRegistry: String!
  "Field that holds the organization's description."
  description: String!
  "Field that holds the organization's email."
  email: String!
  "Field that holds the organization's logo."
  logo: Upload
  "Field that holds the name of the organization."
  name: String!
  """
  Field that provides the user's role within the organizations he's creating.
  Defaults to ADMIN.
  """
  role: UserOrganizationRole! = ADMIN
  "Field that holds the organization's status."
  status: OrganizationStatus!
  "Field that holds the organization's tags."
  tags: [String!]!
  "Field that holds the organization's trading name."
  tradingName: String!
}
"Input used to create a post."
input CreatePostInput {
  "Field that holds the post's body."
  body: String!
  "Field that holds the post's images."
  images: [Upload!]
  organizationId: ID
  "Field that holds the post's title."
  title: String!
}
"""
Creates a new `Term` and its first initial `TermVersion`. The created
version is a draft (unpublished) and may be edited with
`updateTermVersion()` until it's final, by then one should publish it
with `publishTermVersion()`.
"""
input CreateTermInput {
  term: TermInput!
  termVersion: TermVersionInput!
}
"""
Input that holds basic information about a term.

Used to create a `Term`.
"""
input TermInput {
  "Field that holds the description of a term."
  description: String!
  "Nullable field that can hold the tags of a term."
  tags: [String!]
  "Field that holds the title of a term."
  title: String!
}
"""
Input that holds basic information about a term's version.

Used to create a `TermVersion`.
"""
input TermVersionInput {
  "Field that holds the body of a term's version."
  body: String!
  "Field that holds the description of a term's version."
  description: String!
  "Field that holds the human understandable string version of a term."
  version: String!
}
"Input used to a create term's version."
input CreateTermVersionInput {
  "Field that holds the body of this new version."
  body: String!
  "Field that holds the description of this new version."
  description: String!
  "Field that indicates to what term this version belongs to."
  termId: ID!
  "Field that holds the human understandable string of this new version."
  version: String!
}
"""
Input used to create a user.
Username must be unique.
"""
input CreateUserInput {
  "Non-Nullable string that holds an user's email"
  email: String!
  """
  Non-Nullable boolean that holds whether the user is enabled
  the default value is true for created User information
  can be used as valid credentials
  """
  enabled: Boolean! = true
  "Nullable string that can hold an user's first name"
  firstName: String
  "Nullable string that can hold an user's last name"
  lastName: String
  "Non-Nullable string that holds an user's password"
  password: String!
  "Nullable string array that can hold user's required actions"
  requiredActions: [String!]
  "Non-Nullable string that holds an user's username"
  username: String!
}
"Input used to update user status given its id."
input DeactivateUserInput {
  "Not nullable field that indicates which user should be deactivated."
  userId: ID!
}
"Input used to delete an organization."
input DeleteOrganizationInput {
  "Field that indicates what organization should be deleted."
  organizationId: ID!
}
"This input holds info for a basic login, using username and password."
input LoginInput {
  "String that has the password for the user trying to log in."
  password: String!
  "String that has the username for the user trying to log in."
  username: String!
}
"Input that is used to publish a term's version"
input PublishTermVersionInput {
  """
  String that is used to prevent mid-air collisions. To successfully publish a
  term's version, this field **has to be the same** as the `etag` field of
  the term's version being updated.

  If this condition is not met, an error will be returned.
  """
  ifMatchesETag: String!
  "Field that holds a `TermVersion` unique identifier"
  termVersionId: ID!
}
"This input is used to refresh a Login"
input RefreshInput {
  "Refresh token generated by a Login or another refreshToken mutation"
  token: String!
}
"Input used to register a webhook."
input RegisterWebhookInput {
  "Field that holds webhook's status."
  active: Boolean!
  "Field that holds webhook's configuration."
  config: WebhookConfigInput!
  "Field that holds webhook's events."
  events: [SubscribableEvents!]!
  "Field that holds webhook's name."
  name: String!
}
"Input used to register a webhook configuration."
input WebhookConfigInput {
  "Field that holds webhook's method."
  method: WebhookRequestMethod!
  "Field that holds http server's url."
  url: String!
}
"Input used to remove a post."
input RemovePostInput {
  "Field that indicates what post should be removed."
  id: ID!
  "Field that holds reason of post removal"
  reason: String!
}
"Input used to remove a connection between an user and a organization"
input RemoveUserFromOrganizationInput {
  organizationId: ID!
  userId: ID!
}
"Input used to send an email to a user given it's id"
input ResetPasswordInput {
  """
  Field that indicates the email of the user whose password must be reset.
  A link to reset the password will be sent to the informed email (if the user exists)
  """
  email: String!
}
"Input used to restore a post."
input RestorePostInput {
  "Field that indicates which post should be restored."
  id: ID!
}
"Input used to trigger a webhook"
input TriggerWebhookEvent {
  "Field that holds the event that trigger webhook"
  triggerEvent: SubscribableEvents!
  "Field that holds webhook's id"
  webhookId: ID!
  "Field that holds Json data to be send as body of HTTP request"
  webhookJsonData: JSONObject!
}
"Input used to update an organization."
input UpdateOrganizationInput {
  "If given (non-null), updates the organization's corporate taxpayer registry."
  corporateTaxpayerRegistry: String
  "If given (non-null), updates the organization's description."
  description: String
  "If given (non-null), updates the organization's email."
  email: String
  """
  String that is used to prevent mid-air collisions. To successfully update an
  organization, this field **has to be the same** as the `etag` field of
  the organization that is being updated.

  If this condition is not met, an error will be returned.
  """
  ifMatchesETag: String!
  "If given (non-null), updates the organization's logo."
  logo: Upload
  "If given (non-null), updates the name of the organization."
  name: String
  "Field that indicates what organization should be updated."
  organizationId: ID!
  "If given (non-null), updates the organization's status."
  status: OrganizationStatus
  "If given (non-null), updates the organization's tags."
  tags: [String!]
  "If given (non-null), updates the organization's trading name."
  tradingName: String
}
"""
Input used to update a term version.

Published versions cannot be updated.
"""
input UpdateTermVersionInput {
  "If given (non-null), updates the version's body."
  body: String
  "If given (non-null), updates the version's description."
  description: String
  """
  String that is used to prevent mid-air collisions. To successfully update a
  term's version, this field **has to be the same** as the `etag` field of
  the term's version being updated.

  If this condition is not met, an error will be returned.
  """
  ifMatchesETag: String!
  "Field that indicates to what term version should be updated."
  termVersionId: ID!
  "If given (non-null), updates the version's version."
  version: String
}
"""
Input used to update a user given its id.
Cannot update username because keycloak does not support it.
"""
input UpdateUserInput {
  "Nullable string that holds an user's email"
  email: String
  "Nullable string that can hold an user's first name"
  firstName: String
  "Nullable string that can hold an user's last name"
  lastName: String
  """
  Field that indicates which user should be updated.
  If `null` the logged user will be updated.
  """
  userId: ID
}
